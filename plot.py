"""
Render a Factorio research graph from JSONL into an interactive HTML DAG,
optionally with a static PDF export.

This script reads the JSONL file produced by the crawler and constructs a
directed graph whose nodes are technologies and whose edges represent research
dependencies. The preferred parent relation is taken from
"required_technologies_merged" when present, and otherwise from
"required_technologies".

Each node is rendered using the scraped research icon image when available.
For HTML output, the graph is built with PyVis / vis-network and displayed as a
top-down hierarchical DAG. Images are embedded directly into the HTML as data
URIs so that the resulting file is self-contained and does not depend on
external image files at viewing time.

The HTML output is interactive:
    - nodes can be hovered for metadata,
    - the graph can be panned and zoomed,
    - and research relationships can be explored visually.

Optionally, the script can also export a static PDF version through Graphviz.
This requires both the Python graphviz package and a local Graphviz
installation.

Input:
    - A JSONL file where each line describes one research node, typically
      generated by main.py.

Output:
    - An interactive HTML file visualizing the tech tree.
    - Optionally, a PDF file if Graphviz export is requested.

Typical usage:
    python plot.py \
        --input-jsonl ./data/tech_tree.jsonl \
        --output-html ./data/tech_tree.html

    python plot.py \
        --input-jsonl ./data/tech_tree.jsonl \
        --output-html ./data/tech_tree.html \
        --pdf ./data/tech_tree.pdf

Notes:
    - HTML is the preferred output format because it supports embedded images
      and interactive inspection.
    - The graph is rendered hierarchically from prerequisites to descendants.
    - Nodes without a valid scraped image are still displayed, but fall back to
      a simple non-image node shape.
"""

import argparse
import base64
import json
import mimetypes
from pathlib import Path
from typing import Dict, List, Optional

from pyvis.network import Network


def load_jsonl(path: Path) -> List[Dict]:
    """
    Load a JSONL file from disk into a list of records.

    Args:
        path: Path to the JSONL file.

    Returns:
        List of parsed JSON objects.

    Raises:
        ValueError: If any line is not valid JSON.
    """
    records = []
    with open(path, "r", encoding="utf-8") as f:
        for line_num, line in enumerate(f, start=1):
            line = line.strip()
            if not line:
                continue
            try:
                records.append(json.loads(line))
            except json.JSONDecodeError as e:
                raise ValueError(f"Invalid JSON on line {line_num}: {e}") from e
    return records


def image_file_to_data_uri(path: Path) -> Optional[str]:
    """
    Convert an image file to a data URI string.

    Args:
        path: Path to the image file.

    Returns:
        Data URI string if the file exists, otherwise None.

    Raises:
        None
    """
    if not path.exists():
        return None

    mime, _ = mimetypes.guess_type(str(path))
    if mime is None:
        mime = "application/octet-stream"

    with open(path, "rb") as f:
        raw = f.read()

    b64 = base64.b64encode(raw).decode("ascii")
    return f"data:{mime};base64,{b64}"


def choose_parent_field(rec: Dict) -> List[str]:
    """
    Choose the most appropriate parent field from a record.

    Args:
        rec: Record dictionary.

    Returns:
        List of parent technology IDs.

    Raises:
        None
    """
    if "required_technologies_merged" in rec and rec["required_technologies_merged"] is not None:
        return rec["required_technologies_merged"]
    if "required_technologies" in rec and rec["required_technologies"] is not None:
        return rec["required_technologies"]
    return []


def strip_research_suffix(title: str) -> str:
    """
    Remove a trailing " (research)" suffix from a title if present.

    Args:
        title: Original title string.

    Returns:
        Cleaned title string.

    Raises:
        None
    """
    suffix = " (research)"
    if title.endswith(suffix):
        return title[: -len(suffix)]
    return title


def compute_research_depths(records: List[Dict]) -> Dict[str, int]:
    """
    Compute research depth for each node using parent relationships.

    Args:
        records: Parsed tech tree records.

    Returns:
        Mapping of node id to depth level (root nodes are depth 0).

    Raises:
        ValueError: If a cycle is detected in the graph.
    """
    rec_by_id: Dict[str, Dict] = {rec["id"]: rec for rec in records}
    in_degree: Dict[str, int] = {node_id: 0 for node_id in rec_by_id}
    children: Dict[str, List[str]] = {node_id: [] for node_id in rec_by_id}

    for node_id, rec in rec_by_id.items():
        parents = choose_parent_field(rec)
        for parent_id in parents:
            if parent_id not in rec_by_id:
                continue
            if parent_id == node_id:
                continue
            in_degree[node_id] += 1
            children[parent_id].append(node_id)

    queue = [node_id for node_id, degree in in_degree.items() if degree == 0]
    depths: Dict[str, int] = {node_id: 0 for node_id in queue}
    visited = 0

    while queue:
        node_id = queue.pop(0)
        visited += 1
        node_depth = depths.get(node_id, 0)
        for child_id in children[node_id]:
            child_depth = max(depths.get(child_id, 0), node_depth + 1)
            depths[child_id] = child_depth
            in_degree[child_id] -= 1
            if in_degree[child_id] == 0:
                queue.append(child_id)

    if visited != len(rec_by_id):
        raise ValueError("Cycle detected in research graph; cannot compute depths.")

    for node_id in rec_by_id:
        depths.setdefault(node_id, 0)

    return depths


def build_html_graph(
    records: List[Dict],
    output_html: Path,
    height: str = "900px",
    width: str = "100%",
) -> None:
    """
    Build an interactive HTML tech tree visualization.

    Args:
        records: Parsed tech tree records.
        output_html: Output HTML file path.
        height: HTML graph height.
        width: HTML graph width.

    Returns:
        None

    Raises:
        None
    """
    rec_by_id: Dict[str, Dict] = {}
    for rec in records:
        node_id = rec["id"]
        rec_by_id[node_id] = rec

    depths = compute_research_depths(records)

    net = Network(
        height=height,
        width=width,
        directed=True,
        notebook=False,
        bgcolor="#ffffff",
        font_color="#000000",
    )

    # Hierarchical DAG-style layout.
    net.set_options(
        """
        {
          "layout": {
            "hierarchical": {
              "enabled": true,
              "direction": "UD",
              "sortMethod": "directed",
              "nodeSpacing": 180,
              "levelSeparation": 400,
              "treeSpacing": 220,
              "blockShifting": true,
              "edgeMinimization": true,
              "parentCentralization": true
            }
          },
          "physics": {
            "enabled": false
          },
          "interaction": {
            "hover": true,
            "navigationButtons": true,
            "keyboard": true
          },
          "edges": {
            "arrows": {
              "to": {
                "enabled": true,
                "scaleFactor": 0.8
              }
            },
            "smooth": {
              "enabled": true,
              "type": "cubicBezier",
              "roundness": 0.4
            },
            "color": {
              "color": "#666666",
              "highlight": "#222222"
            }
          },
          "nodes": {
            "shape": "image",
            "size": 32,
            "borderWidth": 2,
            "borderWidthSelected": 3,
            "font": {
              "size": 18,
              "face": "Arial"
            },
            "shapeProperties": {
              "useBorderWithImage": true,
              "borderRadius": 0
            }
          }
        }
        """
    )

    # Add nodes.
    for node_id, rec in rec_by_id.items():
        title = rec.get("title") or node_id
        display_title = strip_research_suffix(title)
        internal_name = rec.get("internal_name") or node_id
        url = rec.get("url", "")
        is_space_age = rec.get("is_space_age_exclusive", False)
        img_path = rec.get("image_path")

        image_uri = None
        if img_path:
            p = Path(img_path)
            if p.exists():
                image_uri = image_file_to_data_uri(p)

        hover_lines = [
            f"<b>{display_title}</b>",
            f"internal_name: {internal_name}",
            f"id: {node_id}",
        ]
        if url:
            hover_lines.append(f"url: {url}")
        hover_lines.append(f"space_age_exclusive: {is_space_age}")

        net.add_node(
            node_id,
            label=display_title,
            title="<br>".join(hover_lines),
            image=image_uri,
            shape="image" if image_uri else "box",
            size=38 if image_uri else 20,
            level=depths.get(node_id, 0),
            shapeProperties={"useBorderWithImage": True, "borderRadius": 0},
        )

    # Add edges parent -> child.
    for node_id, rec in rec_by_id.items():
        parents = choose_parent_field(rec)
        for parent_id in parents:
            if parent_id not in rec_by_id:
                continue
            net.add_edge(parent_id, node_id)

    output_html.parent.mkdir(parents=True, exist_ok=True)
    net.write_html(str(output_html), notebook=False)


def build_pdf_graph_with_graphviz(records: List[Dict], output_pdf: Path) -> None:
    """
    Optional static PDF export using graphviz.
    Images are used as node images if graphviz can resolve the file paths.

    Args:
        records: Parsed tech tree records.
        output_pdf: Output PDF path.

    Returns:
        None

    Raises:
        RuntimeError: If graphviz is not available.
    """
    try:
        from graphviz import Digraph
    except ImportError as e:
        raise RuntimeError(
            "PDF export requires the 'graphviz' Python package. "
            "Install it with: pip install graphviz"
        ) from e

    dot = Digraph("factorio_tech_tree", format="pdf")
    dot.attr(rankdir="TB", splines="true", overlap="false")
    dot.attr("node", shape="box", fontsize="12", fontname="Arial")
    dot.attr("edge", arrowsize="0.7")

    rec_by_id: Dict[str, Dict] = {rec["id"]: rec for rec in records}

    for node_id, rec in rec_by_id.items():
        title = rec.get("title") or node_id
        display_title = strip_research_suffix(title)
        img_path = rec.get("image_path")

        if img_path and Path(img_path).exists():
            # Graphviz image nodes work best with absolute paths.
            abs_img = str(Path(img_path).resolve())
            label = display_title.replace('"', '\\"')
            dot.node(
                node_id,
                label=label,
                image=abs_img,
                labelloc="b",
                imagescale="true",
                fixedsize="false",
            )
        else:
            dot.node(node_id, label=display_title)

    for node_id, rec in rec_by_id.items():
        parents = choose_parent_field(rec)
        for parent_id in parents:
            if parent_id not in rec_by_id:
                continue
            dot.edge(parent_id, node_id)

    output_pdf.parent.mkdir(parents=True, exist_ok=True)
    tmp_out = str(output_pdf.with_suffix(""))
    dot.render(tmp_out, cleanup=True)


def parse_args() -> argparse.Namespace:
    """
    Parse command line arguments.

    Args:
        None

    Returns:
        Parsed argparse namespace.

    Raises:
        None
    """
    parser = argparse.ArgumentParser(
        description=(
            "Read a Factorio tech-tree JSONL file and render it as an interactive HTML DAG, "
            "optionally also exporting a PDF via Graphviz."
        )
    )
    parser.add_argument(
        "--input-jsonl",
        type=str,
        required=True,
        help="Path to input JSONL file produced by the scraper.",
    )
    parser.add_argument(
        "--output-html",
        type=str,
        default="factorio_tech_tree.html",
        help="Path to output HTML file.",
    )
    parser.add_argument(
        "--pdf",
        type=str,
        default=None,
        help="Optional output PDF path. Requires graphviz installed.",
    )
    return parser.parse_args()


def main() -> None:
    """
    Entry point for the tech tree renderer.

    Args:
        None

    Returns:
        None

    Raises:
        None
    """
    args = parse_args()

    input_jsonl = Path(args.input_jsonl)
    output_html = Path(args.output_html)

    records = load_jsonl(input_jsonl)
    build_html_graph(records, output_html)

    print(f"[DONE] Wrote HTML DAG to {output_html}")

    if args.pdf:
        output_pdf = Path(args.pdf)
        build_pdf_graph_with_graphviz(records, output_pdf)
        print(f"[DONE] Wrote PDF DAG to {output_pdf}")


if __name__ == "__main__":
    main()
